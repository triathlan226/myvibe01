<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>特種兵生存競技場 - 自動火力走位版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #2c3e50;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
        }

        .stat-bar {
            width: 240px;
            height: 18px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff;
            margin-bottom: 10px;
            position: relative;
            border-radius: 9px;
            overflow: hidden;
        }

        #hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #c0392b, #e74c3c); transition: width 0.2s; }
        #xp-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #f39c12, #f1c40f); transition: width 0.2s; }

        .cooldown-container {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .cd-box {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #bdc3c7;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            position: relative;
            border-radius: 6px;
        }

        .cd-fill {
            width: 100%;
            height: 0%;
            background: rgba(255, 255, 255, 0.4);
            position: absolute;
            bottom: 0;
            transition: height 0.1s linear;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .hidden { display: none !important; }

        .card-container {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }

        .selection-card {
            background: #34495e;
            padding: 25px;
            width: 240px;
            text-align: center;
            border: 3px solid #7f8c8d;
            cursor: pointer;
            border-radius: 15px;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .selection-card:hover { 
            transform: translateY(-10px); 
            border-color: #f1c40f; 
            background: #2c3e50;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        .selection-card h3 { color: #f1c40f; margin-top: 0; }
        .selection-card p { font-size: 0.9em; color: #ecf0f1; }

        #hurt-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(192, 57, 43, 0.5) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }

        .btn {
            padding: 15px 50px;
            font-size: 22px;
            background: #27ae60;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 30px;
            margin-top: 30px;
            font-weight: bold;
            box-shadow: 0 4px 0 #219150;
        }

        .btn:hover { background: #2ecc71; transform: translateY(-2px); }
        .btn:active { transform: translateY(2px); box-shadow: none; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="hurt-overlay"></div>

    <!-- HUD 介面 -->
    <div id="hud" class="ui-layer">
        <div style="font-weight: bold; color: #f1c40f; font-size: 1.4em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">等級: <span id="level-val">1</span></div>
        <div class="stat-bar"><div id="hp-fill"></div></div>
        <div class="stat-bar"><div id="xp-fill"></div></div>
        <div class="cooldown-container">
            <div class="cd-box">
                <div class="cd-fill" id="fill-dash"></div>
                <span>SPACE</span>
                <span>翻滾</span>
            </div>
            <div class="cd-box">
                <div class="cd-fill" id="fill-sprint"></div>
                <span>SHIFT</span>
                <span>衝刺</span>
            </div>
            <div class="cd-box" style="border-color: #e74c3c;">
                <div class="cd-fill" id="fill-airstrike"></div>
                <span>AUTO</span>
                <span>空中轟炸</span>
            </div>
        </div>
        <div style="margin-top:15px; font-size: 1.1em;">存活: <span id="time-val">0:00</span></div>
        <div style="font-size: 1.1em;">擊殺: <span id="kill-val">0</span></div>
        <div style="margin-top:10px; color: #3498db; font-weight: bold;">目前武器: <span id="weapon-val">-</span></div>
    </div>

    <!-- 武器選擇選單 -->
    <div id="weapon-menu" class="overlay">
        <h1 style="color: #f1c40f; font-size: 3.5em; margin-bottom: 0;">選擇你的武裝</h1>
        <p style="font-size: 1.2em; color: #bdc3c7;">戰場已清理完成，請選擇初始武器進入競技場</p>
        <div class="card-container">
            <div class="selection-card" onclick="pickWeapon('RIFLE')">
                <h3>突擊步槍</h3>
                <p>標準配置，高射速、中等傷害。</p>
                <p style="color: #3498db;">射速: ★★★★☆</p>
            </div>
            <div class="selection-card" onclick="pickWeapon('SHOTGUN')">
                <h3>戰術散彈槍</h3>
                <p>一次發射多枚彈藥，近距離霸主。</p>
                <p style="color: #e67e22;">範圍: ★★★★★</p>
            </div>
            <div class="selection-card" onclick="pickWeapon('RAILGUN')">
                <h3>電磁長槍</h3>
                <p>射速慢，但子彈具有強大貫穿力。</p>
                <p style="color: #9b59b6;">貫穿: ★★★★★</p>
            </div>
        </div>
        <div style="margin-top: 40px; text-align: center; color: #7f8c8d; font-size: 0.9em;">
            操作提示：WASD 移動，系統自動鎖定射擊與呼叫支援
        </div>
    </div>

    <!-- 升級選單 -->
    <div id="upgrade-menu" class="overlay hidden">
        <h2 style="font-size: 2.5em; color: #f1c40f;">戰術升級</h2>
        <div id="upgrade-options" class="card-container"></div>
    </div>

    <!-- 結束畫面 -->
    <div id="game-over" class="overlay hidden">
        <h1 style="color: #e74c3c; font-size: 4em;">任務失敗</h1>
        <p id="final-stats" style="font-size: 1.8em; margin: 20px 0;"></p>
        <button class="btn" onclick="location.reload()">重新部署</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const hurtOverlay = document.getElementById('hurt-overlay');

    const CANVAS_WIDTH = 1200;
    const CANVAS_HEIGHT = 800;
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    let gameState = 'MENU';
    let lastTime = 0;
    let spawnTimer = 0;
    let gameTime = 0;
    let kills = 0;
    let level = 1;
    let xp = 0;
    let xpToNext = 100;

    let player;
    let projectiles = [];
    let enemies = [];
    let particles = [];
    let xpGems = [];

    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    class Player {
        constructor(weaponType) {
            this.x = CANVAS_WIDTH / 2;
            this.y = CANVAS_HEIGHT / 2;
            this.radius = 18;
            this.color = '#3498db';
            this.hp = 100;
            this.maxHp = 100;
            this.speed = 4.2;
            this.targetAngle = 0;
            this.currentTarget = null;
            this.invulnerable = false;

            // 武器屬性
            this.weaponType = weaponType;
            this.setupWeapon(weaponType);

            this.lastShot = 0;
            this.lastAirstrike = 0;
            this.airstrikeCD = 8000; // 自動轟炸頻率

            this.cooldowns = {
                dash: { max: 1200, current: 0, duration: 200 },
                sprint: { max: 3000, current: 0, duration: 800 }
            };

            this.isDashing = false;
            this.dashTimer = 0;
            this.isSprinting = false;
            this.sprintTimer = 0;
        }

        setupWeapon(type) {
            this.weaponName = "未知";
            if (type === 'RIFLE') {
                this.damage = 35;
                this.fireRate = 120;
                this.weaponName = "突擊步槍";
                this.bulletType = 'NORMAL';
            } else if (type === 'SHOTGUN') {
                this.damage = 25;
                this.fireRate = 600;
                this.weaponName = "戰術散彈槍";
                this.bulletType = 'SCATTER';
            } else if (type === 'RAILGUN') {
                this.damage = 120;
                this.fireRate = 800;
                this.weaponName = "電磁長槍";
                this.bulletType = 'PIERCE';
            }
        }

        update(dt) {
            // 更新冷卻
            for (let key in this.cooldowns) {
                if (this.cooldowns[key].current > 0) this.cooldowns[key].current -= dt;
            }

            // 自動轟炸計時
            if (this.lastAirstrike < this.airstrikeCD) {
                this.lastAirstrike += dt;
            } else {
                this.autoAirstrike();
                this.lastAirstrike = 0;
            }

            // 處理狀態
            if (this.isDashing) {
                this.dashTimer -= dt;
                if (this.dashTimer <= 0) {
                    this.isDashing = false;
                    this.invulnerable = false;
                }
            }
            if (this.isSprinting) {
                this.sprintTimer -= dt;
                if (this.sprintTimer <= 0) this.isSprinting = false;
            }

            // 移動控制
            let mx = 0, my = 0;
            if (keys['KeyW']) my -= 1;
            if (keys['KeyS']) my += 1;
            if (keys['KeyA']) mx -= 1;
            if (keys['KeyD']) mx += 1;

            if (mx !== 0 || my !== 0) {
                const moveAngle = Math.atan2(my, mx);
                let currentSpeed = this.speed;
                if (this.isDashing) currentSpeed *= 3;
                else if (this.isSprinting) currentSpeed *= 1.8;

                this.x += Math.cos(moveAngle) * currentSpeed;
                this.y += Math.sin(moveAngle) * currentSpeed;
            }

            // 技能觸發
            if (keys['Space'] && this.cooldowns.dash.current <= 0) {
                this.isDashing = true;
                this.invulnerable = true;
                this.dashTimer = this.cooldowns.dash.duration;
                this.cooldowns.dash.current = this.cooldowns.dash.max;
            }
            if (keys['ShiftLeft'] && this.cooldowns.sprint.current <= 0) {
                this.isSprinting = true;
                this.sprintTimer = this.cooldowns.sprint.duration;
                this.cooldowns.sprint.current = this.cooldowns.sprint.max;
            }

            // 自動瞄準邏輯
            this.findNearestTarget();
            if (this.currentTarget) {
                this.targetAngle = Math.atan2(this.currentTarget.y - this.y, this.currentTarget.x - this.x);
                if (Date.now() - this.lastShot > this.fireRate) {
                    this.shoot();
                    this.lastShot = Date.now();
                }
            }

            this.x = Math.max(this.radius, Math.min(CANVAS_WIDTH - this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(CANVAS_HEIGHT - this.radius, this.y));
        }

        findNearestTarget() {
            let minDist = 700;
            let target = null;
            enemies.forEach(en => {
                const d = Math.hypot(en.x - this.x, en.y - this.y);
                if (d < minDist) { minDist = d; target = en; }
            });
            this.currentTarget = target;
        }

        shoot() {
            if (this.bulletType === 'NORMAL') {
                projectiles.push(new Projectile(this.x, this.y, this.targetAngle, this.damage, 14, false));
            } else if (this.bulletType === 'SCATTER') {
                for(let i = -2; i <= 2; i++) {
                    projectiles.push(new Projectile(this.x, this.y, this.targetAngle + (i * 0.15), this.damage, 10, false));
                }
            } else if (this.bulletType === 'PIERCE') {
                projectiles.push(new Projectile(this.x, this.y, this.targetAngle, this.damage, 20, true));
            }
        }

        autoAirstrike() {
            const count = 3 + Math.floor(level / 2);
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    // 優先選取敵人密集的座標，否則隨機
                    let tx, ty;
                    if (enemies.length > 0 && Math.random() > 0.3) {
                        const luckyEn = enemies[Math.floor(Math.random() * enemies.length)];
                        tx = luckyEn.x + (Math.random() - 0.5) * 100;
                        ty = luckyEn.y + (Math.random() - 0.5) * 100;
                    } else {
                        tx = Math.random() * CANVAS_WIDTH;
                        ty = Math.random() * CANVAS_HEIGHT;
                    }
                    particles.push({ x: tx, y: ty, r: 0, maxR: 180, life: 1200, type: 'WARNING' });
                    setTimeout(() => createExplosion(tx, ty, 180, 400), 1200);
                }, i * 300);
            }
        }

        takeDamage(amt) {
            if (this.invulnerable) return;
            this.hp -= amt;
            hurtOverlay.style.opacity = 1;
            setTimeout(() => hurtOverlay.style.opacity = 0, 100);
            if (this.hp <= 0) endGame();
        }

        draw() {
            // 瞄準雷射線
            if (this.currentTarget) {
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.currentTarget.x, this.currentTarget.y);
                ctx.strokeStyle = 'rgba(231, 76, 60, 0.4)';
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.targetAngle);

            // 角色主體
            ctx.fillStyle = this.invulnerable ? '#fff' : this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
            ctx.fill();

            // 武器外觀
            ctx.fillStyle = '#2c3e50';
            if (this.bulletType === 'PIERCE') {
                ctx.fillRect(this.radius - 2, -4, 35, 8); // 長槍管
            } else if (this.bulletType === 'SCATTER') {
                ctx.fillRect(this.radius - 2, -10, 20, 20); // 粗槍管
            } else {
                ctx.fillRect(this.radius - 2, -6, 22, 12); // 標準槍管
            }

            ctx.restore();
        }
    }

    class Projectile {
        constructor(x, y, angle, damage, speed, pierce) {
            this.x = x; this.y = y; this.angle = angle; this.damage = damage;
            this.speed = speed; this.pierce = pierce;
            this.radius = pierce ? 7 : 4;
            this.life = 2500;
            this.hitEnemies = new Set(); // 用於貫穿時避免重複傷害
        }

        update(dt) {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            this.life -= dt;
            return (this.x < -100 || this.x > CANVAS_WIDTH + 100 || this.y < -100 || this.y > CANVAS_HEIGHT + 100 || this.life <= 0);
        }

        draw() {
            ctx.fillStyle = this.pierce ? '#9b59b6' : '#f1c40f';
            if (this.pierce) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#9b59b6';
            }
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class Enemy {
        constructor(type) {
            const side = Math.floor(Math.random() * 4);
            if (side === 0) { this.x = Math.random() * CANVAS_WIDTH; this.y = -50; }
            else if (side === 1) { this.x = CANVAS_WIDTH + 50; this.y = Math.random() * CANVAS_HEIGHT; }
            else if (side === 2) { this.x = Math.random() * CANVAS_WIDTH; this.y = CANVAS_HEIGHT + 50; }
            else { this.x = -50; this.y = Math.random() * CANVAS_HEIGHT; }

            this.type = type;
            const multiplier = 1 + (gameTime / 60000);

            if (type === 'TANK') {
                this.radius = 35;
                this.hp = 500 * multiplier;
                this.speed = 1.0;
                this.color = '#c0392b';
                this.damage = 40;
                this.xpVal = 70;
            } else {
                this.radius = 16;
                this.hp = 80 * multiplier;
                this.speed = 2.4 + Math.random() * 0.6;
                this.color = '#27ae60';
                this.damage = 15;
                this.xpVal = 20;
            }
        }

        update() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.x += Math.cos(angle) * this.speed;
            this.y += Math.sin(angle) * this.speed;

            const dist = Math.hypot(player.x - this.x, player.y - this.y);
            if (dist < player.radius + this.radius) {
                player.takeDamage(this.damage / 60);
            }
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // 血條
            const max = this.type === 'TANK' ? 500 * (1 + gameTime/60000) : 80 * (1 + gameTime/60000);
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(this.x - 25, this.y - this.radius - 12, 50, 6);
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(this.x - 25, this.y - this.radius - 12, Math.max(0, (this.hp / max) * 50), 6);
        }
    }

    class XPGem {
        constructor(x, y, val) { this.x = x; this.y = y; this.val = val; this.radius = 6; }
        update() {
            const dist = Math.hypot(player.x - this.x, player.y - this.y);
            if (dist < 220) {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * 9;
                this.y += Math.sin(angle) * 9;
            }
            if (dist < player.radius + this.radius) {
                addXP(this.val);
                return true;
            }
            return false;
        }
        draw() {
            ctx.fillStyle = '#f1c40f';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#f1c40f';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    function createExplosion(x, y, radius, damage) {
        particles.push({ x, y, r: 10, maxR: radius, life: 500, type: 'EXPLOSION' });
        enemies.forEach(en => {
            const dist = Math.hypot(en.x - x, en.y - y);
            if (dist < radius + en.radius) en.hp -= damage;
        });
    }

    function addXP(amt) {
        xp += amt;
        if (xp >= xpToNext) levelUp();
    }

    function levelUp() {
        level++;
        xp -= xpToNext;
        xpToNext = Math.floor(xpToNext * 1.3);
        gameState = 'UPGRADE';
        showUpgradeMenu();
    }

    function showUpgradeMenu() {
        const menu = document.getElementById('upgrade-menu');
        const optionsDiv = document.getElementById('upgrade-options');
        menu.classList.remove('hidden');
        optionsDiv.innerHTML = '';

        const allUpgrades = [
            { name: '火力強化', desc: '武器傷害 +35%', action: () => player.damage *= 1.35 },
            { name: '高頻零件', desc: '武器射速提升 25%', action: () => player.fireRate *= 0.75 },
            { name: '冷卻優化', desc: '轟炸支援頻率提升 30%', action: () => player.airstrikeCD *= 0.7 },
            { name: '輕型外殼', desc: '移動速度 +12%', action: () => player.speed *= 1.12 },
            { name: '緊急護盾', desc: '位移冷卻縮短 25%', action: () => { player.cooldowns.dash.max *= 0.75; player.cooldowns.sprint.max *= 0.75; } },
            { name: '修復包', desc: '恢復所有生命值並增加 30 點上限', action: () => { player.maxHp += 30; player.hp = player.maxHp; } }
        ];

        allUpgrades.sort(() => 0.5 - Math.random()).slice(0, 3).forEach(up => {
            const card = document.createElement('div');
            card.className = 'selection-card';
            card.innerHTML = `<h3>${up.name}</h3><p>${up.desc}</p>`;
            card.onclick = () => { up.action(); menu.classList.add('hidden'); gameState = 'PLAYING'; };
            optionsDiv.appendChild(card);
        });
    }

    function pickWeapon(type) {
        player = new Player(type);
        document.getElementById('weapon-menu').classList.add('hidden');
        document.getElementById('weapon-val').innerText = player.weaponName;
        resetGameParams();
        gameState = 'PLAYING';
        requestAnimationFrame(gameLoop);
    }

    function resetGameParams() {
        projectiles = []; enemies = []; particles = []; xpGems = [];
        gameTime = 0; kills = 0; level = 1; xp = 0; xpToNext = 100;
        lastTime = performance.now();
    }

    function endGame() {
        gameState = 'GAMEOVER';
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('final-stats').innerText = `生存時間: ${formatTime(gameTime)} | 擊殺數: ${kills}`;
    }

    function formatTime(ms) {
        const sec = Math.floor(ms / 1000);
        return `${Math.floor(sec / 60)}:${(sec % 60).toString().padStart(2, '0')}`;
    }

    function gameLoop(time) {
        const dt = time - lastTime;
        lastTime = time;
        if (gameState === 'PLAYING') update(dt);
        render();
        requestAnimationFrame(gameLoop);
    }

    function update(dt) {
        gameTime += dt;
        player.update(dt);

        spawnTimer += dt;
        const spawnRate = Math.max(200, 1400 - (gameTime / 120));
        if (spawnTimer > spawnRate) {
            enemies.push(new Enemy(Math.random() < Math.min(0.5, gameTime / 150000) ? 'TANK' : 'NORMAL'));
            spawnTimer = 0;
        }

        projectiles = projectiles.filter(p => {
            const removed = p.update(dt);
            if (!removed) {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const en = enemies[i];
                    if (Math.hypot(p.x - en.x, p.y - en.y) < p.radius + en.radius) {
                        if (p.pierce) {
                            if (!p.hitEnemies.has(en)) {
                                en.hp -= p.damage;
                                p.hitEnemies.add(en);
                            }
                        } else {
                            en.hp -= p.damage;
                            if (en.hp <= 0) {
                                kills++;
                                xpGems.push(new XPGem(en.x, en.y, en.xpVal));
                                enemies.splice(i, 1);
                            }
                            return false; // 非貫穿彈碰到敵人就消失
                        }

                        if (en.hp <= 0) {
                            kills++;
                            xpGems.push(new XPGem(en.x, en.y, en.xpVal));
                            enemies.splice(i, 1);
                        }
                    }
                }
            }
            return !removed;
        });

        enemies.forEach(en => en.update());
        xpGems = xpGems.filter(gem => !gem.update());
        particles = particles.filter(p => {
            p.life -= dt;
            if (p.type === 'EXPLOSION') p.r += (p.maxR - p.r) * 0.15;
            return p.life > 0;
        });

        // UI 數據刷新
        document.getElementById('hp-fill').style.width = (player.hp / player.maxHp * 100) + '%';
        document.getElementById('xp-fill').style.width = (xp / xpToNext * 100) + '%';
        document.getElementById('level-val').innerText = level;
        document.getElementById('time-val').innerText = formatTime(gameTime);
        document.getElementById('kill-val').innerText = kills;
        document.getElementById('fill-dash').style.height = (player.cooldowns.dash.current / player.cooldowns.dash.max * 100) + '%';
        document.getElementById('fill-sprint').style.height = (player.cooldowns.sprint.current / player.cooldowns.sprint.max * 100) + '%';
        document.getElementById('fill-airstrike').style.height = (100 - (player.lastAirstrike / player.airstrikeCD * 100)) + '%';
    }

    function render() {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // 畫格線 (增加空間感)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 1;
        for(let i=0; i<CANVAS_WIDTH; i+=100) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, CANVAS_HEIGHT); ctx.stroke(); }
        for(let j=0; j<CANVAS_HEIGHT; j+=100) { ctx.beginPath(); ctx.moveTo(0, j); ctx.lineTo(CANVAS_WIDTH, j); ctx.stroke(); }

        xpGems.forEach(gem => gem.draw());
        enemies.forEach(en => en.draw());
        projectiles.forEach(p => p.draw());
        if (player) player.draw();
        
        particles.forEach(p => {
            if (p.type === 'EXPLOSION') {
                ctx.fillStyle = `rgba(230, 126, 34, ${p.life / 500})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2); ctx.fill();
            } else if (p.type === 'WARNING') {
                ctx.strokeStyle = `rgba(255, 0, 0, ${p.life / 1200})`;
                ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.maxR, 0, Math.PI * 2); ctx.stroke();
                ctx.fillStyle = `rgba(255, 0, 0, 0.1)`; ctx.fill();
            }
        });
    }
</script>

</body>
</html>